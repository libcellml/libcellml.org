import{t as T,r as j,c as f,o as t,a,b as v,d as n,e as k,f as g,F as l,g as B,h as s,w as m,V as P,u as r,_ as I,i as y,j as L,k as M,l as $,m as V,n as F}from"./index-45856ec8.js";const K={key:0},O=["href"],R=["href"],S={key:1},A={key:2},x={__name:"ValidationProvenance",props:{version:String},setup(C){const w=C,{version:i}=T(w),o=j(e()),h=f(()=>`https://github.com/${o.value.testing_framework.project}/tree/${o.value.testing_framework.reference}`),c=f(()=>`https://github.com/${o.value.testing_database.project}/tree/${o.value.testing_database.reference}`),_=f(()=>o.value.testing_framework.reference),b=f(()=>o.value.testing_database.reference),p=f(()=>{const u=`/generated/${i.value}/validation_provenance.json`;return fetch(u).then(D=>{D.json().then(N=>{o.value=N},()=>{o.value=e()})}),!1}),d=f(()=>o.value.testing_framework.reference!=="unknown"&&o.value.testing_database.reference!=="unknown");function e(){return{testing_framework:{reference:"unknown",project:"unknown"},testing_database:{reference:"unknown",project:"unknown"}}}return(u,D)=>(t(),a(l,null,[d.value?(t(),a("span",K,[v(" This documentation was validated with "),n("a",{href:h.value,target:"_blank"},k(_.value),9,O),v(" of the end-2-end testing framework and "),n("a",{href:c.value,target:"_blank"},k(b.value),9,R),v(" of the end-2-end test database. ")])):(t(),a("span",S," There is no known validation of this documentation with the libCellML library. ")),p.value?(t(),a("span",A)):g("",!0)],64))}},E=n("h1",null,"Documentation",-1),G=n("p",null,"General documentation for all versions.",-1),H=n("br",null,null,-1),q=n("br",null,null,-1),z=n("h2",null,"Version specific documentation",-1),J=n("br",null,null,-1),Q=n("br",null,null,-1),U=n("h3",null,"Previous versions of the documentation",-1),W=n("p",null," Previous versions listed in reverse semantic versioning order. Only the most recent patch release for each version is available. ",-1),X={style:{"padding-left":"2.5rem"}},Y={key:0},Z=n("br",null,null,-1),ne={__name:"DocumentationHome",setup(C){const{checkDocumentationAvailability:w,documentationInfoMap:i}=L(),o=M(),h=o[0],c=j([]),_=Object.keys(i);for(const b of o){let p={};for(const e of _)p[e]=j(!1);const d={version:b,...p};for(const e of _)w(d[e],b,e);c.value.push(d)}return(b,p)=>{const d=B("router-link");return t(),a(l,null,[E,G,H,s(P,null,{default:m(()=>[s($,null,{default:m(()=>[s(V,{label:"Installation","icon-name":"mdi-download",target:"/documentation/installation"})]),_:1}),s($,null,{default:m(()=>[s(V,{label:"Theory","icon-name":"mdi-lightbulb-outline",target:"/documentation/theory"})]),_:1})]),_:1}),q,z,n("p",null,[v(" Documentation for "),n("strong",null,k(r(h)),1),v(" of libCellML. "),s(x,{version:r(h)},null,8,["version"])]),J,s(I),Q,s(P,null,{default:m(()=>[(t(!0),a(l,null,y(r(_),e=>(t(),a(l,{key:"secondary_button_"+e},[r(i)[e].level===2&&c.value[0][e]?(t(),F($,{key:0},{default:m(()=>[s(V,{id:e,label:r(i)[e].label,"icon-name":r(i)[e].iconName,target:`/documentation/${c.value[0].version}/${e}`},null,8,["id","label","icon-name","target"])]),_:2},1024)):g("",!0)],64))),128))]),_:1}),U,W,(t(!0),a(l,null,y(c.value,e=>(t(),a("div",{key:"older_"+e.version},[e.version!==r(h)?(t(),a(l,{key:0},[n("h4",null,k(e.version),1),n("ul",X,[(t(!0),a(l,null,y(r(_),u=>(t(),a(l,{key:"list_item_"+u},[e[u]?(t(),a("li",Y,[s(d,{to:`/documentation/${e.version}/${u}`},{default:m(()=>[v(k(r(i)[u].label),1)]),_:2},1032,["to"])])):g("",!0)],64))),128))]),n("p",null,[s(x,{version:e.version},null,8,["version"])])],64)):g("",!0),Z]))),128))],64)}}};export{ne as default};
